### 行为的详细规范

#### 总体规范

我们唯一要求的结构是你必须有一个名为 `gitlet.Main` 的类，并且它必须包含一个 `main` 方法。

我们还提供了一些实用方法，用于执行许多主要与文件系统相关的任务，这样你可以集中精力处理项目的逻辑，而不必担心操作系统的细节。

我们还添加了两个建议的类：`Commit` 和 `Repository`，以帮助你入门。当然，你可以编写其他 Java 类来支持你的项目，或者根据需要删除我们建议的类。但请不要使用任何外部代码（除了 JUnit），也不要使用除 Java 以外的任何编程语言。你可以使用你所需的所有 Java 标准库，以及我们提供的工具。

你不应该在 `Main` 类中完成所有工作。你的 `Main` 类应该主要调用 `Repository` 类中的辅助方法。请参见第 6 次实验中的 `CapersRepository` 和 `Main` 类，以获取我们推荐的结构示例。

本规范的大部分内容将描述当 `Gitlet.java` 的 `main` 方法接收到各种 gitlet 命令作为命令行参数时必须如何反应。但在逐条分解命令之前，这里有一些整体指导方针，整个项目应满足：

1. **存储位置**：为了使 Gitlet 工作，它需要一个存储旧文件副本和其他元数据的地方。所有这些内容必须存储在一个名为 `.gitlet` 的目录中，就像真实的 git 系统将这些信息存储在 `.git` 目录中一样（以 `.` 开头的文件是隐藏文件。在大多数操作系统中，默认情况下你将无法看到它们。在 Unix 系统中，使用 `ls -a` 命令可以显示它们）。如果某个位置有一个 `.gitlet` 目录，则认为该 Gitlet 系统已在该位置“初始化”。大多数 Gitlet 命令（除了 `init` 命令）仅在从已初始化 Gitlet 系统的目录中使用时有效，即在包含 `.gitlet` 目录的目录中。未在 `.gitlet` 目录中的文件（这些文件是你正在使用和编辑的代码库中的副本，以及你计划添加到代码库中的文件）被称为工作目录中的文件。

2. **运行时和内存使用要求**：大多数命令都有运行时或内存使用要求。你必须遵循这些要求。一些运行时被描述为相对于任何重要度量的常量。“重要度量”包括：文件的数量或大小的任何度量、提交的数量的任何度量。你可以忽略序列化或反序列化所需的时间，唯一的例外是你的序列化时间不能以任何方式依赖于已添加、提交等的文件总大小（什么是序列化？如果你不知道，请回顾第 6 次实验！）。你还可以假设从哈希表中获取数据是常数时间。

3. **错误处理**：一些命令有失败情况，并指定了错误消息。这些错误消息的确切格式将在后面规范中指定。所有错误消息都以句号结束；由于我们的自动评分是逐字的，请确保包含它。如果你的程序遇到这些失败情况之一，必须打印错误消息而不更改其他任何内容。你不需要处理除列出的失败情况以外的其他错误情况。

4. **通用失败情况**：以下是一些需要处理的失败情况，这些情况不适用于特定命令：
   - 如果用户没有输入任何参数，打印消息“Please enter a command.”并退出。
   - 如果用户输入了一个不存在的命令，打印消息“No command with that name exists.”并退出。
   - 如果用户输入了一个操作数数量或格式错误的命令，打印消息“Incorrect operands.”并退出。
   - 如果用户输入了一个需要在初始化的 Gitlet 工作目录中（即，包含 `.gitlet` 子目录的目录）才能执行的命令，但不在这样的目录中，打印消息“Not in an initialized Gitlet directory.”。

5. **与真实 Git 的差异**：一些命令与真实 Git 的差异已列出。规范并未详尽列出与 Git 的所有差异，但列出了一些较大或可能令人困惑和误导的差异。

6. **输出限制**：请不要打印出除了规范所说的内容以外的任何内容。我们的某些自动评分测试将在你打印多余内容时失败。

7. **退出程序**：要立即退出程序，你可以调用 `System.exit(0)`。例如，如果在辅助函数中发生错误并希望立即终止 gitlet，你可以调用此函数。注意：你始终应提供参数 0 给 `System.exit(0)` 命令。在 61C 中，你将学习该参数（称为错误代码）的含义。

8. **危险命令**：规范将一些命令分类为“危险”。危险命令是指那些可能覆盖文件（而不仅仅是元数据）的命令——例如，如果用户告诉 Gitlet 恢复文件到旧版本，Gitlet 可能会覆盖当前版本的文件。仅供参考。在测试这些命令时，请小心！